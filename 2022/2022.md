# 2022 Research Log

## 2022/3/10

Get the number of concurrent threads system supported:

```c++
#include <thread>

unsigned int n = std::thread::hardware_concurrency();
```

## 2022/3/9

I find the matrix multiplication program performance is very poor(when two 1000 * 1000 matrixs are multiplied, it will spend a lot of time), so I improve the algorithm of multi-threads matrix multiplication:

```c++
#include <iostream>
#include <utility>
#include <vector>
#include <thread>
#include <cmath>
#include <fstream>

#define DEBUG

class Matrix {
private:
    typedef std::vector<std::vector<int>> matrix_type;
    typedef unsigned long rank_type;
    typedef std::vector<int> vector_type;
    friend class PMatrix;
    rank_type row, column;
    matrix_type matrix;
public:
    explicit Matrix(matrix_type m) {
        row = m.size();
        column = !row ? 0 : m[0].size();
        matrix = m;
    }
    Matrix(): Matrix(matrix_type()) {}
    friend std::ifstream &operator>>(std::ifstream &input, Matrix &m) {
        input >> m.row;
        input >> m.column;
        for (rank_type r = 0; r < m.row; ++r) {
            vector_type v;
            for (rank_type c = 0; c < m.column; ++c) {
                int t;
                input >> t;
                v.push_back(t);
            }
            m.matrix.push_back(v);
        }
        return input;
    }
    friend std::ostream &operator<<(std::ostream &output, const Matrix &m) {
        for (const vector_type &v : m.matrix) {
            for (int element : v)
                output << element << "\t";
            output << std::endl;
        }
        return output;
    }
    Matrix operator*(const Matrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            for (rank_type i = 0; i < row; ++i) {
                vector_type v;
                for (rank_type j = 0; j < m.column; ++j) {
                    int element = 0;
                    for (rank_type k = 0; k < column; ++k) {
                        element += matrix[i][k] * m.matrix[k][j];
                    }
                    v.push_back(element);
                }
                tmp.push_back(v);
            }
        }
        Matrix result(tmp);
        return result;
    }
};

class PMatrix: public Matrix {
private:
    static const unsigned long threads_num = 4;
    static void _thread(matrix_type &result, PMatrix mA, PMatrix mB, rank_type block, rank_type start_row) {
        for (rank_type i = start_row; i < start_row + block; ++i) {
            vector_type v;
            for (rank_type j = 0; j < mB.column; ++j) {
                int element = 0;
                for (rank_type k = 0; k < mA.column; ++k) {
                    element += mA.matrix[i][k] * mB.matrix[k][j];
                }
                v.push_back(element);
            }
            result.push_back(v);
        }
    }
public:
    [[maybe_unused]] explicit PMatrix(const Matrix &m) {
        row = m.row;
        column = m.column;
        matrix = m.matrix;
    }
    explicit PMatrix(matrix_type m): Matrix(std::move(m)) {}
    PMatrix operator*(const PMatrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            rank_type block = std::ceil((double)row / (double)threads_num);
            std::vector<matrix_type> results(threads_num);
            std::vector<std::thread> threads;
            for (unsigned long t = 0; t < threads_num; ++t)
                threads.emplace_back(std::thread(_thread, std::ref(results[t]), *this, m, (row - t * block >= block ? block : row - t * block), t * block));
            for (std::thread &t : threads)
                t.join();
            for (matrix_type &r : results)
                tmp.insert(tmp.end(), r.begin(), r.end());
        }
        PMatrix result(tmp);
        return result;
    }
};

class Timer {
private:
    std::chrono::time_point<std::chrono::steady_clock> _start, _end;
    std::chrono::duration<double> diff{};
public:
    Timer() {
        _start = std::chrono::steady_clock::now();
        _end = _start;
        diff = _end - _start;
    }
    void start() {
        _start = std::chrono::steady_clock::now();
    }
    void end() {
        _end = std::chrono::steady_clock::now();
        diff = _end - _start;
    }
    double time() {
        return diff.count();
    }
};

int main([[maybe_unused]] int argc, [[maybe_unused]] char *argv[]) {
    std::ifstream mA;
    mA.open("./mA.txt", std::ios::in);
    std::ifstream mB;
    mB.open("./mB.txt", std::ios::in);
    Timer timer;
    Matrix A;
    Matrix B;
    mA >> A;
    mB >> B;
#ifdef DEBUG
    std::cout << "Matrix A:" << std::endl;
    std::cout << A;
    std::cout << "Matrix B:" << std::endl;
    std::cout << B;
#endif
    timer.start();
    Matrix R = A * B;
    timer.end();
#ifdef DEBUG
    std::cout << "Result:" << std::endl;
    std::cout << R;
#endif
    std::cout << "Time: " << timer.time() << std::endl;
    PMatrix pA = (PMatrix)A;
    PMatrix pB = (PMatrix)B;
    timer.start();
    PMatrix pR = pA * pB;
    timer.end();
#ifdef DEBUG
    std::cout << "P Result:" << std::endl;
    std::cout << pR;
#endif
    std::cout << "P Time: " << timer.time() << std::endl;
    return 0;
}
```

Improve point:

Parallelized method in version 1 will use *n* threads to compute one element in result. It will execute *create-join* operation *matrixA.row \* matrixB.column \* n* times.

But in version 2, matrixA is divided into *n* small matrix, and one thread compute the multiplication of every small matrix and matrixB.

***Benchmark***:

| **row/column** | **time(1 thread)** | **time(4 threads)** | **time(8 threads)** |
| -------------- | ------------------ | ------------------- | ------------------- |
| **10**         | 0.000039554        | 0.000390017         | 0.000522796         |
| **20**         | 0.000133721        | 0.000360164         | 0.000447025         |
| **30**         | 0.000329015        | 0.000494832         | 0.000562465         |
| **40**         | 0.000645744        | 0.000647674         | 0.000681134         |
| **50**         | 0.00114985         | 0.000851287         | 0.000950188         |
| **60**         | 0.00191395         | 0.00107704          | 0.00123167          |
| **70**         | 0.00283829         | 0.00151404          | 0.0015221           |
| **80**         | 0.0040848          | 0.00193485          | 0.00190089          |
| **90**         | 0.00565676         | 0.00247712          | 0.00235211          |
| **100**        | 0.00753642         | 0.0031971           | 0.00268168          |
| **500**        | 0.960772           | 0.269345            | 0.145958            |
| **1000**       | 11.9551            | 3.22906             | 1.93215             |
| **2000**       | 134.269            | 35.539              | 18.0095             |

![pic1](./pic/2022030901.jpg)

![pic2](./pic/2022030902.jpg)

## 2022/3/8

Repair the matrix multiplication program:

```c++
#include <iostream>
#include <utility>
#include <vector>
#include <thread>
#include <cmath>
#include <fstream>

class Matrix {
private:
    typedef std::vector<std::vector<int>> matrix_type;
    typedef unsigned long rank_type;
    typedef std::vector<int> vector_type;
    friend class PMatrix;
    rank_type row, column;
    matrix_type matrix;
public:
    explicit Matrix(matrix_type m) {
        row = m.size();
        column = !row ? 0 : m[0].size();
        matrix = m;
    }
    Matrix(): Matrix(matrix_type()) {}
    friend std::ifstream &operator>>(std::ifstream &input, Matrix &m) {
        input >> m.row;
        input >> m.column;
        for (rank_type r = 0; r < m.row; ++r) {
            vector_type v;
            for (rank_type c = 0; c < m.column; ++c) {
                int t;
                input >> t;
                v.push_back(t);
            }
            m.matrix.push_back(v);
        }
        return input;
    }
    friend std::ostream &operator<<(std::ostream &output, const Matrix &m) {
        for (const vector_type &v : m.matrix) {
            for (int element : v)
                output << element << "\t";
            output << std::endl;
        }
        return output;
    }
    Matrix operator*(const Matrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            for (rank_type i = 0; i < row; ++i) {
                vector_type v;
                for (rank_type j = 0; j < m.column; ++j) {
                    int element = 0;
                    for (rank_type k = 0; k < column; ++k) {
                        element += matrix[i][k] * m.matrix[k][j];
                    }
                    v.push_back(element);
                }
                tmp.push_back(v);
            }
        }
        Matrix result(tmp);
        return result;
    }
};

std::mutex mut;

class PMatrix: public Matrix {
private:
    static const unsigned long threads_num = 4;
    static void _thread(int &element, PMatrix mA, PMatrix mB, rank_type i, rank_type j, rank_type k, rank_type gap) {
        while (gap--) {
            mut.lock();
            element += mA.matrix[i][k] * mB.matrix[k][j];
            mut.unlock();
            k++;
        }
    }
public:
    [[maybe_unused]] explicit PMatrix(const Matrix &m) {
        row = m.row;
        column = m.column;
        matrix = m.matrix;
    }
    explicit PMatrix(matrix_type m): Matrix(std::move(m)) {}
    PMatrix operator*(const PMatrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            for (rank_type i = 0; i < row; ++i) {
                vector_type v;
                for (rank_type j = 0; j < m.column; ++j) {
                    int element = 0;
                    rank_type gap = std::ceil((double)column / (double)threads_num);
                    std::vector<std::thread> threads;
                    for (unsigned long t = 0; t < threads_num; ++t) {
                        threads.emplace_back(std::thread(_thread, std::ref(element), *this, m, i, j, t * gap, (column - t * gap >= gap) ? gap : (column - t * gap)));
                    }
                    for (std::thread &t : threads) {
                        t.join();
                    }
                    v.push_back(element);
                }
                tmp.push_back(v);
            }
        }
        PMatrix result(tmp);
        return result;
    }
};

class Timer {
private:
    std::chrono::time_point<std::chrono::steady_clock> _start, _end;
    std::chrono::duration<double> diff{};
public:
    Timer() {
        _start = std::chrono::steady_clock::now();
        _end = _start;
        diff = _end - _start;
    }
    void start() {
        _start = std::chrono::steady_clock::now();
    }
    void end() {
        _end = std::chrono::steady_clock::now();
        diff = _end - _start;
    }
    double time() {
        return diff.count();
    }
};

int main([[maybe_unused]] int argc, [[maybe_unused]] char *argv[]) {
    std::ifstream mA;
    mA.open("/Users/gabriel/Desktop/matrix_multiplication/mA.txt", std::ios::in);
    std::ifstream mB;
    mB.open("/Users/gabriel/Desktop/matrix_multiplication/mB.txt", std::ios::in);
    Timer timer;
    Matrix A;
    Matrix B;
    mA >> A;
    mB >> B;
    std::cout << "Matrix A:" << std::endl;
    std::cout << A;
    std::cout << "Matrix B:" << std::endl;
    std::cout << B;
    timer.start();
    Matrix R = A * B;
    timer.end();
    std::cout << "Result:" << std::endl;
    std::cout << R;
    std::cout << "Time: " << timer.time() << std::endl;
    PMatrix pA = (PMatrix)A;
    PMatrix pB = (PMatrix)B;
    timer.start();
    PMatrix pR = pA * pB;
    timer.end();
    std::cout << "P Result:" << std::endl;
    std::cout << pR;
    std::cout << "Time: " << timer.time() << std::endl;
    return 0;
}
```

And write a program to generate matrix for benchmarking:

```c++
#include <iostream>
#include <vector>
#include <random>
#include <fstream>
#include <sstream>

class Matrix {
public:
    typedef std::vector<std::vector<int>> matrix_type;
    typedef unsigned long rank_type;
    typedef std::vector<int> vector_type;
private:
    [[maybe_unused]] rank_type row, column;
    matrix_type matrix;
public:
    explicit Matrix(matrix_type m) {
        row = m.size();
        column = !row ? 0 : m[0].size();
        matrix = m;
    }
    friend std::ostream &operator<<(std::ostream &output, const Matrix &m) {
        for (const vector_type &v : m.matrix) {
            for (int element : v)
                output << element << " ";
            output << std::endl;
        }
        return output;
    }
};

class MatrixGenerator {
private:
    int mArow, mAcolumn_mBrow, mBcolumn;
    Matrix *mA = nullptr, *mB = nullptr;
public:
    MatrixGenerator(int _mArow, int _mAcolumn_mBrow, int _mBcolumn): mArow(_mArow), mAcolumn_mBrow(_mAcolumn_mBrow), mBcolumn(_mBcolumn) {
        std::random_device r;
        std::default_random_engine e1(r());
        std::uniform_int_distribution<int> uniform_dist(0, 99);
        Matrix::matrix_type mAv, mBv;
        for (int i = 0; i < mArow; ++i) {
            Matrix::vector_type v;
            for (int j = 0; j < mAcolumn_mBrow; ++j)
                v.push_back(uniform_dist(e1));
            mAv.push_back(v);
        }
        for (int i = 0; i < mAcolumn_mBrow; ++i) {
            Matrix::vector_type v;
            for (int j = 0; j < mBcolumn; ++j)
                v.push_back(uniform_dist(e1));
            mBv.push_back(v);
        }
        mA = new Matrix(mAv);
        mB = new Matrix(mBv);
    }
    ~MatrixGenerator() {
        delete mA;
        delete mB;
    }
    void save() {
        if (mA && mB) {
            std::ofstream fileA, fileB;
            std::stringstream ss;
            fileA.open("./mA.txt", std::ios::out);
            ss << mArow << " " << mAcolumn_mBrow << std::endl;
            ss << *mA << std::endl;
            fileA << ss.str();
            fileA.close();
            ss.clear();
            ss.str("");
            fileB.open("./mB.txt", std::ios::out);
            ss << mAcolumn_mBrow << " " << mBcolumn << std::endl;
            ss << *mB << std::endl;
            fileB << ss.str();
            fileB.close();
        }
    }
};

int main([[maybe_unused]] int argc, [[maybe_unused]] char * argv[]) {
    int mArow, mAcolumn_mBrow, mBcolumn;
    std::cout << "Input Matrix A - row: ";
    std::cin >> mArow;
    std::cout << "Input Matrix A - column: ";
    std::cin >> mAcolumn_mBrow;
    std::cout << "Matrix B - row: " << mAcolumn_mBrow << std::endl;
    std::cout << "Input Matrix B - column: ";
    std::cin >> mBcolumn;
    MatrixGenerator mg(mArow, mAcolumn_mBrow, mBcolumn);
    mg.save();
    return 0;
}
```

TODO:

Benchmarking.

## 2022/3/7

Test program can run rightly by deleting reference from thread function:

```c++
static void _thread(int &result, PVector v1, PVector v2, int start, unsigned long gap) {
    while (gap--) {
        mut.lock();
        result += v1.vec[start] * v2.vec[start];
        mut.unlock();
        start++;
    }
}
```

Generate a thread by this:

```c++
threads.emplace_back(std::thread(_thread, std::ref(result), *this, v, i * gap, size - i * gap >= gap ? gap : size - i * gap));
```

So that it will not use any reference of object of class PVector.

***Reference Page*** of `std::thread` and `std::ref`:

* https://en.cppreference.com/w/cpp/thread/thread/thread
* https://en.cppreference.com/w/cpp/utility/functional/ref

## 2022/3/4

A simple program can cause same error:

```c++
#include <iostream>
#include <vector>
#include <thread>
#include <cmath>

std::mutex mut;

class PVector {
private:
    static const unsigned long threads_num = 2;
    unsigned long size;
    std::vector<int> vec;
    static void _thread(int &result, PVector &v1, PVector &v2, int start, unsigned long gap) {
        while (gap--) {
            mut.lock();
            result += v1.vec[start] * v2.vec[start];
            mut.unlock();
            start++;
        }
    }
public:
    explicit PVector(const std::vector<int> &v): vec(v), size(v.size()) {}
    int operator*(const PVector &v) const {
        int result = 0;
        unsigned long gap = std::ceil((double)size / (double)threads_num);
        std::vector<std::thread> threads;
        threads.reserve(threads_num);
        for (int i = 0; i < threads_num; ++i)
            threads.emplace_back(std::thread(_thread, std::ref(result),std::ref(*this), std::ref(v), i * gap, size - i * gap >= gap ? gap : size - i * gap));
        for (std::thread &t : threads)
            t.join();
        return result;
    }
};

int main() {
    PVector v1(std::vector{1, 2, 3, 4, 5, 6, 7, 8, 9});
    PVector v2(std::vector{9, 8, 7, 6, 5, 4, 3, 2, 1});
    int n = v1 * v2;
    std::cout << n << std::endl;
    return 0;
}
```

Just using clang to compile this program:

```
In file included from ./main.cpp:3:
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/thread:286:5: error: attempt to use a deleted function
    _VSTD::__invoke(_VSTD::move(_VSTD::get<1>(__t)), _VSTD::move(_VSTD::get<_Indices>(__t))...);
    ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__config:856:15: note: expanded from macro '_VSTD'
#define _VSTD std::_LIBCPP_ABI_NAMESPACE
              ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/thread:297:12: note: in instantiation of function template specialization 'std::__thread_execute<std::unique_ptr<std::__thread_struct>, void (*)(int &, PVector &, PVector &, int, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PVector>, std::reference_wrapper<const PVector>, unsigned long, unsigned long, 2, 3, 4, 5, 6>' requested here
    _VSTD::__thread_execute(*__p.get(), _Index());
           ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/thread:313:54: note: in instantiation of function template specialization 'std::__thread_proxy<std::tuple<std::unique_ptr<std::__thread_struct>, void (*)(int &, PVector &, PVector &, int, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PVector>, std::reference_wrapper<const PVector>, unsigned long, unsigned long>>' requested here
    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());
                                                     ^
./main.cpp:29:34: note: in instantiation of function template specialization 'std::thread::thread<void (&)(int &, PVector &, PVector &, int, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PVector>, std::reference_wrapper<const PVector>, unsigned long, unsigned long, void>' requested here
            threads.emplace_back(std::thread(_thread, std::ref(result),std::ref(*this), std::ref(v), i * gap, size - i * gap >= gap ? gap : size - i * gap));
                                 ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits:1916:5: note: '~__nat' has been explicitly marked deleted here
    ~__nat() = delete;
    ^
1 error generated.
```

TODO:

Solve this problem.

## 2022/3/3

Matrix multiplication: (with some problems)

```c++
#include <iostream>
#include <utility>
#include <vector>
#include <thread>
#include <cmath>
#include <fstream>

class Matrix {
private:
    typedef std::vector<std::vector<int>> matrix_type;
    typedef unsigned long rank_type;
    typedef std::vector<int> vector_type;
    friend class PMatrix;
    rank_type row, column;
    matrix_type matrix;
public:
    explicit Matrix(matrix_type m) {
        row = m.size();
        column = !row ? 0 : m[0].size();
        matrix = m;
    }
    Matrix(): Matrix(matrix_type()) {}
    friend std::ifstream &operator>>(std::ifstream &input, Matrix &m) {
        input >> m.row;
        input >> m.column;
        for (rank_type r = 0; r < m.row; ++r) {
            vector_type v;
            for (rank_type c = 0; c < m.column; ++c) {
                int t;
                input >> t;
                v.push_back(t);
            }
            m.matrix.push_back(v);
        }
        return input;
    }
    friend std::ostream &operator<<(std::ostream &output, const Matrix &m) {
        for (const vector_type &v : m.matrix) {
            for (int element : v)
                output << element << "\t";
            output << std::endl;
        }
        return output;
    }
    Matrix operator*(const Matrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            for (rank_type i = 0; i < row; ++i) {
                vector_type v;
                for (rank_type j = 0; j < m.column; ++j) {
                    int element = 0;
                    for (rank_type k = 0; k < column; ++k) {
                        element += matrix[i][k] * m.matrix[k][j];
                    }
                    v.push_back(element);
                }
                tmp.push_back(v);
            }
        }
        Matrix result(tmp);
        return result;
    }
};

std::mutex mut;

class PMatrix: public Matrix {
private:
    static const unsigned long threads_num = 4;
    static void _thread(int &element, PMatrix &mA, PMatrix &mB, rank_type i, rank_type j, rank_type k, rank_type gap) {
        while (gap--) {
            mut.lock();
            element += mA.matrix[i][k] * mB.matrix[k][j];
            mut.unlock();
            k++;
        }
    }
public:
    [[maybe_unused]] explicit PMatrix(const Matrix &m) {
        row = m.row;
        column = m.column;
        matrix = m.matrix;
    }
    explicit PMatrix(matrix_type m): Matrix(std::move(m)) {}
    PMatrix operator*(const PMatrix &m) const {
        matrix_type tmp;
        if (column == m.row) {
            for (rank_type i = 0; i < row; ++i) {
                vector_type v;
                for (rank_type j = 0; j < m.column; ++j) {
                    int element = 0;
                    rank_type gap = std::ceil((double)column / (double)threads_num);
                    std::vector<std::thread> threads;
                    for (unsigned long t = 0; t < threads_num; ++t) {
                        threads.emplace_back(std::thread(_thread, std::ref(element), std::ref(*this), std::ref(m), i, j, t * gap, (column - t * gap >= gap) ? gap : (column - t * gap)));
                    }
                    for (std::thread &t : threads) {
                        t.join();
                    }
                    v.push_back(element);
                }
                tmp.push_back(v);
            }
        }
        PMatrix result(tmp);
        return result;
    }
};

class Timer {
private:
    std::chrono::time_point<std::chrono::steady_clock> _start, _end;
    std::chrono::duration<double> diff{};
public:
    Timer() {
        _start = std::chrono::steady_clock::now();
        _end = _start;
        diff = _end - _start;
    }
    void start() {
        _start = std::chrono::steady_clock::now();
    }
    void end() {
        _end = std::chrono::steady_clock::now();
        diff = _end - _start;
    }
    double time() {
        return diff.count();
    }
};

int main([[maybe_unused]] int argc, [[maybe_unused]] char *argv[]) {
    std::ifstream mA;
    mA.open("/Users/gabriel/Desktop/matrix_multiplication/mA.txt", std::ios::in);
    std::ifstream mB;
    mB.open("/Users/gabriel/Desktop/matrix_multiplication/mB.txt", std::ios::in);
    Timer timer;
    Matrix A;
    Matrix B;
    mA >> A;
    mB >> B;
    std::cout << "Matrix A:" << std::endl;
    std::cout << A;
    std::cout << "Matrix B:" << std::endl;
    std::cout << B;
    timer.start();
    Matrix R = A * B;
    timer.end();
    std::cout << "Result:" << std::endl;
    std::cout << R;
    std::cout << "Time: " << timer.time() << std::endl;
    PMatrix pA = (PMatrix)A;
    PMatrix pB = (PMatrix)B;
    timer.start();
    PMatrix pR = pA * pB;
    timer.end();
    std::cout << "P Result:" << std::endl;
    std::cout << pR;
    std::cout << "Time: " << timer.time() << std::endl;
    return 0;
}
```

I got error messages:

```
====================[ Build | matrix_multiplication | Debug ]===================
"/Users/gabriel/Library/Application Support/JetBrains/Toolbox/apps/CLion/ch-0/213.6777.58/CLion.app/Contents/bin/cmake/mac/bin/cmake" --build /Users/gabriel/Desktop/matrix_multiplication/cmake-build-debug --target matrix_multiplication
[1/2] Building CXX object CMakeFiles/matrix_multiplication.dir/main.cpp.o
FAILED: CMakeFiles/matrix_multiplication.dir/main.cpp.o 
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++   -g -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk -std=gnu++17 -MD -MT CMakeFiles/matrix_multiplication.dir/main.cpp.o -MF CMakeFiles/matrix_multiplication.dir/main.cpp.o.d -o CMakeFiles/matrix_multiplication.dir/main.cpp.o -c /Users/gabriel/Desktop/matrix_multiplication/main.cpp
In file included from /Users/gabriel/Desktop/matrix_multiplication/main.cpp:4:
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/thread:286:5: error: attempt to use a deleted function
    _VSTD::__invoke(_VSTD::move(_VSTD::get<1>(__t)), _VSTD::move(_VSTD::get<_Indices>(__t))...);
    ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/__config:856:15: note: expanded from macro '_VSTD'
#define _VSTD std::_LIBCPP_ABI_NAMESPACE
              ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/thread:297:12: note: in instantiation of function template specialization 'std::__thread_execute<std::unique_ptr<std::__thread_struct>, void (*)(int &, PMatrix &, PMatrix &, unsigned long, unsigned long, unsigned long, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PMatrix>, std::reference_wrapper<const PMatrix>, unsigned long, unsigned long, unsigned long, unsigned long, 2, 3, 4, 5, 6, 7, 8>' requested here
    _VSTD::__thread_execute(*__p.get(), _Index());
           ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/thread:313:54: note: in instantiation of function template specialization 'std::__thread_proxy<std::tuple<std::unique_ptr<std::__thread_struct>, void (*)(int &, PMatrix &, PMatrix &, unsigned long, unsigned long, unsigned long, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PMatrix>, std::reference_wrapper<const PMatrix>, unsigned long, unsigned long, unsigned long, unsigned long>>' requested here
    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());
                                                     ^
/Users/gabriel/Desktop/matrix_multiplication/main.cpp:95:46: note: in instantiation of function template specialization 'std::thread::thread<void (&)(int &, PMatrix &, PMatrix &, unsigned long, unsigned long, unsigned long, unsigned long), std::reference_wrapper<int>, std::reference_wrapper<const PMatrix>, std::reference_wrapper<const PMatrix>, unsigned long &, unsigned long &, unsigned long, unsigned long, void>' requested here
                        threads.emplace_back(std::thread(_thread, std::ref(element), std::ref(*this), std::ref(m), i, j, t * gap, (column - t * gap >= gap) ? gap : (column - t * gap)));
                                             ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/type_traits:1916:5: note: '~__nat' has been explicitly marked deleted here
    ~__nat() = delete;
    ^
1 error generated.
ninja: build stopped: subcommand failed.
```

I thought this error caused by using std::thread with a class-method, so I wrote a test program:

```c++
#include <iostream>
#include <vector>
#include <thread>

std::mutex m;

class Test {
private:
    int number = 0;
    int count = 0;
    static void _thread(int num, int &e, Test &t) {
        std::cout << num;
        m.lock();
        t.count += num;
        e += num;
        m.unlock();
    }
public:
    void test() {
        int e = 0;
        std::vector<std::thread> threads;
        for (int i = 0; i < 6; ++i) {
            threads.emplace_back(std::thread(_thread, i, std::ref(e), std::ref(*this)));
            number++;
        }
        for (std::thread &t : threads)
            t.join();
        std::cout << std::endl;
        std::cout << number << std::endl;
        std::cout << count << std::endl;
        std::cout << e << std::endl;
    }
};

int main() {
    Test t;
    t.test();
    return 0;
}
```

But I got no error with this test program.

TODO:

Looking for how to solve this error.

## 2022/3/1

Parallelized *for-loop* with Pthreads:

//

## 2022/2/28

A own *for-loop* function:

```c++
#include <iostream>

using namespace std;

template <typename F>
void para_for(int start, F const &f) {
    for (int i = start; f(i); ++i)
        cout << i << endl;
}

int main(int argc, const char * argv[]) {
    int max = 9;
    auto cond = [&](int i) -> bool {
        return i < max;
    };
    para_for(0, cond);
    return 0;
}
```

## 2022/2/27

Pthreads:

Basic usage:

```c++
#include <iostream>
#include <thread>

using namespace std;

void thread_func(int n, int &num) {
    cout << n << endl;
    num = 9;
}

int main(int argc, const char * argv[]) {
    int num = 0;
    thread t0(thread_func, 0, ref(num));
    t0.join();
    cout << num << endl;
    return 0;
}
```

Using *for-loop* creating threads:

```c++
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void thread_func(int n, int &num) {
    cout << n;
    num = n;
}

int main(int argc, const char * argv[]) {
    int num = 0;
    vector<thread> threads;
    for (int i = 0; i < 8; ++i)
        threads.emplace_back(thread(thread_func, i, ref(num)));
    for (thread &t : threads)
        t.join();
    cout << endl;
    cout << num << endl;
    return 0;
}
```

Lambda:

Using lambda expressions as parameters:

```c++
#include <iostream>

using namespace std;

template <typename F>
void test_lambda(F const &f) {
    if (f())
        cout << "True" << endl;
    else
        cout << "False" << endl;
}

int main(int argc, const char * argv[]) {
    int num = 9;
    auto lambda = [&]() -> bool {return num < 9;};
    test_lambda(lambda);
    return 0;
}
```

## 2022/2/25

OCaml:

//

Homework:

```ocaml
let rec union a b =
	match (a, b) with
	| ([], b) -> b
	| (a, []) -> a
	| (ha::ta, hb::tb) ->
		if ha < hb then ha::(union ta b)
		else if ha > hb then hb::(union a tb)
		else ha::(union ta tb);;
```

```ocaml
let rec reverse ls = rev ls []
and rev ls r = match ls with
	| [] -> r
	| h::t -> rev t (h::r);;
```

## 2022/2/23

Parallelization of delta-stepping algorithm:

If there are `m` threads and the loop will be done `n` times:

1. Thread No. 1 will deal with loop 1, 1 + m, 1 + 2m...
2. Thread No. 2 will deal with loop 2, 2 + m, 2 + 2m...
3. Thread No. `x` will deal with loop x, x + m, x + 2m...

![Parallelization of delta-stepping algorithm](./pic/2022022301.jpeg)

## 2022/2/20

Pthreads:

Looking for a generic method to parallelized *for-loop* simply.

## 2022/2/18

OCaml:

//

OCaml Homework:

1. Slide P.15:

```
# sqrt 2.0 *. 2.0;;
- : float = 2.82842712474619029
```

```
# let distance x y = sqrt (x ** 2.0 +. y ** 2.0);;
val distance : float -> float -> float = <fun>
```

2. Slide P.32:

```
# let rec range m n =
  if m > n then []
  else m::range (m + 1) n;;
```

3. Slide P.33:

```
# let rec union a b =
    match a with
    | [] -> b
    | h::t -> if member h b
    then union t b
    else union t (h::b);;
```

## 2022/2/16

Delta-stepping algorithm:

```c++
#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <map>
#include <tuple>
#include <string>
#include <queue>
#include <stack>
#include <thread>
#include <mutex>
#include <chrono>

#define INF 0x3f3f3f3f
#define N 14081999

class Graph {
    int V, E;
    std::map<int, std::vector<std::tuple<int, int, int>>> G;
public:
    bool input_graph(std::string path) {
        std::ifstream file;
        file.open(path, std::ios::in);
        if (!file.is_open())
            return false;
        file >> V;
        file >> E;
        for (int i = 0; i < E; ++i) {
            int u, v, w;
            file >> u >> v >> w;
            G[u].push_back(std::make_tuple(u, v, w));
        }
        return true;
    }
    void show_graph() {
        for (int v = 0; v < V; ++v) {
            std::cout << v << " : ";
            for (auto i = G[v].begin(); i != G[v].end(); ++i)
                std::cout << std::get<0>(*i) << "-(" << std::get<2>(*i) << ")->" << std::get<1>(*i) << "  ";
            std::cout << std::endl;
        }
    }
    int vertices() {
        return V;
    }
    std::vector<std::tuple<int, int, int>> &edges(int v) {
        return G[v];
    }
};

using namespace std;

struct edge {
    int to, cost;
};
struct req {
    int v, w;
};

int delta, tnum;
int n, m, maxbucket, cnt;
int tent[N];
vector<int> B[N];
vector<int> S;
vector<req> REQ;

bool bempty()
{
    for (int i = 0; i <= maxbucket; ++i)
        if(!B[i].empty())
            return false;
    return true;
}

void relax(int w, int d)
{
    if (d < tent[w]) {
        if (tent[w] != INF) {
            vector<int>::iterator res = find(B[tent[w] / delta].begin(), B[tent[w] / delta].end(), w);
            if (res != B[tent[w] / delta].end())
                B[tent[w] / delta].erase(res);
        }
        B[d / delta].push_back(w);
        if (d / delta > maxbucket)
            maxbucket = d / delta;
        tent[w] = d;
    }
}
 
void delta_stepping(int s, Graph G)
{
    maxbucket = 0;
    for (int i = 0; i < n; ++i)
        tent[i] = INF;
    relax(s, 0);
    int j = 0;
    while (!bempty()) {
        S.clear();
        while (!B[j].empty()) {
            REQ.clear();
            // for-loop can be parallelized
            for (int i = 0; i < B[j].size(); ++i) {
                int vv = B[j][i];
                for (int k = 0; k < G.edges(vv).size(); ++k) {
                    if (get<2>(G.edges(vv)[k]) <= delta) {
                        req r;
                        r.v = get<1>(G.edges(vv)[k]);
                        r.w = tent[vv] + get<2>(G.edges(vv)[k]);
                        REQ.push_back(r);
                    }
                }
                S.push_back(vv);
            }
            B[j].clear();
            // for-loop can be parallelized
            for (int i = 0; i < REQ.size(); ++i)
                relax(REQ[i].v, REQ[i].w);
        }
        REQ.clear();
        // for-loop can be parallelized
        for (int i = 0; i < S.size(); ++i) {
            int vv = S[i];
            for (int k = 0; k < G.edges(vv).size(); ++k)
                if (get<2>(G.edges(vv)[k]) > delta) {
                    req r;
                    r.v = get<1>(G.edges(vv)[k]);
                    r.w = tent[vv] + get<2>(G.edges(vv)[k]);
                    REQ.push_back(r);
                }
        }
        // for-loop can be parallelized
        for (int i = 0; i < REQ.size(); ++i)
            relax(REQ[i].v, REQ[i].w);
        j++;
    }
}

int main(int argc, char** argv)
{
    Graph G;
    G.input_graph("./graph.txt");
    delta_stepping(0, G);
    return 0;
}
```

TODO:

* Check the correctness
* Parallelized

## 2022/2/15

面谈:

1. complete the delta- stepping algorithm.
2. Pthreads is recommended, continue learning Pthreads.
3. After mastering how to use Pthreads, I can learn new programming languages.
4. Learning RasPi.
5. Learning GPU programming(on RasPi)
6. Functional programming: OCaml (or Haskell)
7. Material of parallel programming:
   * https://www.cs.cmu.edu/~blelloch/research.html
   * https://www3.cs.stonybrook.edu/~rezaul/CSE613-S17.html
   * https://www.cs.cmu.edu/~guyb/paralg/paralg/parallel.pdf
8. Learning Rust language.
9. Writing research dialog everyday, and supplement previous research logs

## 2022/2/15(前の日誌の整理)

OpenMP:

```c++
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int nthreads, tid;

    #pragma omp parallel private(nthreads, tid)
    {
        tid = omp_get_thread_num();
        printf("Hello World from thread = %d\n", tid);

        if (tid == 0)
        {
            nthreads = omp_get_num_threads();
            printf("Number of threads = %d\n", nthreads);
        }

    }
    return 0;
}
```

Two types of *for-loop*:

```c++
#include <iostream>
 
using namespace std;

int main()
{
#pragma omp parallel  
    for (int i=0; i<10; i++) 
    {
        cout << i;
    } 
 
    return 0;
}
```

```c++
#include <iostream>
 
using namespace std;

int main()
{
#pragma omp parallel for
    for (int i=0; i<10; i++) 
    {
        cout << i;
    } 
 
    return 0;
}
```

Deal with data in loops:

```c++
#include <iostream>
#include <math.h>
 
using namespace std;
int main()
{
    const int NUMBER = 100;
    int* dataA = new int[NUMBER];
    int* dataB = new int[NUMBER];
    for (int i= 0; i < NUMBER; i++) {
        dataA[i] = i + 1;
        dataB[i] = 2 * (i + 1);
    }    
    long double sum = 0.0;
 
    omp_set_num_threads(4);
    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i < NUMBER;  i++) {
        sum += dataA[i] + dataB[i];
    }   
    cout << sum << endl;
 
    delete [] dataA;
    delete [] dataB;
    return 0;
}
```

Other important functions:

```c++
// set the number of threads
_OMPIMP void _OMPAPI omp_set_num_threads(int _Num_threads);
 // get the number of threads now
_OMPIMP int  _OMPAPI omp_get_num_threads(void);
 // get max number of threads
_OMPIMP int  _OMPAPI omp_get_max_threads(void);
 // get thread id
_OMPIMP int  _OMPAPI omp_get_thread_num(void);
 // get cpu core number
_OMPIMP int  _OMPAPI omp_get_num_procs(void);
_OMPIMP void _OMPAPI omp_set_dynamic(int _Dynamic_threads);
_OMPIMP int  _OMPAPI omp_get_dynamic(void);
_OMPIMP int  _OMPAPI omp_in_parallel(void);
_OMPIMP void _OMPAPI omp_set_nested(int _Nested);
_OMPIMP int  _OMPAPI omp_get_nested(void);
_OMPIMP void _OMPAPI omp_init_lock(omp_lock_t * _Lock);
_OMPIMP void _OMPAPI omp_destroy_lock(omp_lock_t * _Lock); _OMPIMP void _OMPAPI omp_set_lock(omp_lock_t * _Lock);
_OMPIMP void _OMPAPI omp_unset_lock(omp_lock_t * _Lock);
_OMPIMP int  _OMPAPI omp_test_lock(omp_lock_t * _Lock);
_OMPIMP void _OMPAPI omp_init_nest_lock(omp_nest_lock_t * _Lock);
_OMPIMP void _OMPAPI omp_destroy_nest_lock(omp_nest_lock_t * _Lock);
_OMPIMP void _OMPAPI omp_set_nest_lock(omp_nest_lock_t * _Lock);
 _OMPIMP void _OMPAPI omp_unset_nest_lock(omp_nest_lock_t * _Lock);
_OMPIMP int  _OMPAPI omp_test_nest_lock(omp_nest_lock_t * _Lock);
_OMPIMP double _OMPAPI omp_get_wtime(void);
_OMPIMP double _OMPAPI omp_get_wtick(void);
```

Dijkstra's algorithm:

```c++
#include <iostream>
#include <fstream>
#include <map>
#include <vector>
#include <tuple>
#include <string>
#include <queue>
#include <stack>
#include <thread>
#include <mutex>
#include <chrono>

class Graph {
    int V, E;
    std::map<int, std::vector<std::tuple<int, int, int>>> G;
public:
    bool input_graph(std::string path) {
        std::ifstream file;
        file.open(path, std::ios::in);
        if (!file.is_open())
            return false;
        file >> V;
        file >> E;
        for (int i = 0; i < E; ++i) {
            int u, v, w;
            file >> u >> v >> w;
            G[u].push_back(std::make_tuple(u, v, w));
        }
        return true;
    }
    void show_graph() {
        for (int v = 0; v < V; ++v) {
            std::cout << v << " : ";
            for (auto i = G[v].begin(); i != G[v].end(); ++i)
                std::cout << std::get<0>(*i) << "-(" << std::get<2>(*i) << ")->" << std::get<1>(*i) << "  ";
            std::cout << std::endl;
        }
    }
    int vertices() {
        return V;
    }
    std::vector<std::tuple<int, int, int>> &edges(int v) {
        return G[v];
    }
};

// Dijkstra
class Dijkstra {
protected:
    Graph G;
    int s;
    int *distTo = nullptr;
    int *edgeTo = nullptr;
    std::chrono::time_point<std::chrono::steady_clock> _start, _end;
    std::chrono::duration<double> diff;
    static bool relax(Dijkstra &D, std::tuple<int, int, int> e, int &r) {
        int u = std::get<0>(e);
        int v = std::get<1>(e);
        int w = std::get<2>(e);
        if (D.distTo[v] > D.distTo[u] + w) {
            D.distTo[v] = D.distTo[u] + w;
            D.edgeTo[v] = u;
            r = v;
            return true;
        }
        return false;
    }
    void start() {
        _start = std::chrono::steady_clock::now();
    }
    void end() {
        _end = std::chrono::steady_clock::now();
        diff = _end - _start;
    }
public:
    static const int INFINITY = 99999;
    Dijkstra(Graph &G, int s): G(G), s(s) {
        distTo = new int[G.vertices()];
        edgeTo = new int[G.vertices()];
        _start = std::chrono::steady_clock::now();
        _end = _start;
    }
    ~Dijkstra() {
        delete [] distTo;
        delete [] edgeTo;
    }
    void run() {
        start();
        for (int v = 0; v < G.vertices(); ++v)
            distTo[v] = INFINITY;
        distTo[s] = 0;
        auto dist_greater = [&](const int &i, const int &j) -> bool { return distTo[i] > distTo[j]; };
        std::priority_queue<int, std::vector<int>, decltype(dist_greater)> minHeap(dist_greater);
        minHeap.push(s);
        while (!minHeap.empty()) {
            int v = minHeap.top();
            minHeap.pop();
            auto edges = G.edges(v);
            #pragma omp parallel for
            for (int i = 0; i < edges.size(); ++i) {
                int r;
                if (relax(*this, edges[i], r))
                    minHeap.push(r);
            }
        }
        end();
    }
    void result() {
        std::cout << "Source: " << s << std::endl;
        for (int i = 0; i < G.vertices(); ++i) {
            std::cout << s << "-(" << distTo[i] << ")->" << i << " : ";
            std::stack<int> path;
            for (int j = i; j != s; j = edgeTo[j])
                path.push(j);
            path.push(s);
            while (!path.empty()) {
                std::cout << path.top() << " ";
                path.pop();
            }
            std::cout << std::endl;
        }
    }
    void time() {
        std::cout << "Time: " << diff.count() << std::endl;
    }
};

// Main
int main(int argc, char *argv[])
{
    if (argc == 1) {
        Graph G;
        // G.input_graph(std::string(argv[1]));
        G.input_graph("./graph.txt");
        // G.show_graph();
        Dijkstra D(G, 0);
        D.run();
        D.result();
        D.time();
    }
    return 0;
}
```

## 2022/1/12

Delta-stepping algorithm:

```c++
#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>

#define INF 0x3f3f3f3f
#define N 14081999

using namespace std;

struct edge {
    int to, cost;
};
struct req {
    int v, w;
};

int delta, tnum;
int n, m, maxbucket, cnt;
fstream f, ss;
vector<edge> G[N];
int tent[N];
vector<int> B[N];
vector<int> S;
vector<req> REQ;
int source[999];

bool bempty()
{
    for (int i = 0; i <= maxbucket; ++i)
        if(!B[i].empty())
            return false;
    return true;
}

void relax(int w, int d)
{
    if (d < tent[w]) {
        if (tent[w] != INF) {
            vector<int>::iterator res = find(B[tent[w] / delta].begin(), B[tent[w] / delta].end(), w);
            if (res != B[tent[w] / delta].end())
                B[tent[w] / delta].erase(res);
        }
        B[d / delta].push_back(w);
        if (d / delta > maxbucket)
            maxbucket = d / delta;
        tent[w] = d;
    }
}
 
void delta_stepping(int s)
{
    maxbucket = 0;
    for (int i = 0; i < n; ++i)
        tent[i] = INF;
    relax(s, 0);
    int j = 0;
    while (!bempty()) {
        S.clear();
        while (!B[j].empty()) {
            REQ.clear();
            // for-loop can be parallelized
            for (int i = 0; i < B[j].size(); ++i) {
                int vv = B[j][i];
                for (int k = 0; k < G[vv].size(); ++k)
                    if (G[vv][k].cost <= delta) {
                        req r;
                        r.v = G[vv][k].to;
                        r.w = tent[vv] + G[vv][k].cost;
                        REQ.push_back(r);
                    }
                S.push_back(vv);
            }
            B[j].clear();
            // for-loop can be parallelized
            for (int i = 0; i < REQ.size(); ++i)
                relax(REQ[i].v, REQ[i].w);
        }
        REQ.clear();
        // for-loop can be parallelized
        for (int i = 0; i < S.size(); ++i) {
            int vv = S[i];
            for (int k = 0; k < G[vv].size(); ++k)
                if (G[vv][k].cost > delta) {
                    req r;
                    r.v = G[vv][k].to;
                    r.w = tent[vv] + G[vv][k].cost;
                    REQ.push_back(r);
                }
        }
        // for-loop can be parallelized
        for (int i = 0; i < REQ.size(); ++i)
            relax(REQ[i].v, REQ[i].w);
        j++;
    }
}
```

TODO:

* Graph Class
* Parallelized

## 2022/1/2

面白い問題一つです。

中国のDMアプリでオイラー路を解けたRed Packetがもらえるゲームがあります。彼女からとっても複雑のオイラー路問題がもらった、一応Undirected Graphのオイラー路を解けるプログラムを書きました。

```c++
#include <iostream>
#include <fstream>

int vertices, edges;
int matrix[999][999];
int degree[999];
int c_count = 0;
int circuit[999];

void DFS(int s)
{
    for (int i = 0; i < vertices; ++i) {
        if (matrix[s][i]) {
            matrix[s][i] = matrix[i][s] = 0;
            DFS(i);
        }
    }
    circuit[c_count++] = s;
}

int main(int argc, char const *argv[])
{
    for (int i = 0; i < 999; ++i)
        for (int j = 0; j < 999; ++j)
            matrix[i][j] = 0;
    std::ifstream file;
    file.open("./redpacket_graph.txt", std::ios::in);
    if (!file.is_open())
        return -1;
    file >> vertices;
    file >> edges;
    for (int i = 0; i < edges; ++i) {
        int u, v;
        file >> u >> v;
        matrix[u][v] = matrix[v][u] = 1;
        degree[u]++;
        degree[v]++;
    }
    int count = 0;
    int start = 0;
    for (int i = 0; i < vertices; ++i) {
        if (degree[i] % 2 == 1) {
            count++;
            start = i;
        }
    }
    if (count != 0 && count != 2) {
        return -1;
    }
    else {
        DFS(start);
        for (int i = 0; i < c_count; ++i) {
            std::cout << circuit[i] << " ";
        }
        std::cout << std::endl;
    }
    return 0;
}
```

DFSでオイラー路が解けます。プログラムが読める図はEdge Graph Formatで表示します。

今の研究と関係がないが、おもしろい問題ですそしてこれも図の問題です、だから研究日誌に記録します。